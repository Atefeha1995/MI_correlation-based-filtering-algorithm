





# Packages
```{r}
library(mpmi)
```








# Main MI and correlation function
```{r}
correlation_based_filtering = function(X_tarin, y_train, MI_threshold, cor_threshold){
  
  # Inputs: 
  # 1) X_train
  # 2) y_train
  # 3) MI_threshold which is a threshold for the mutual information score between the features (X_train) and the response variable (y_train)
  # 4) cor_threshold which is a threshold for the linear correlation between the features (X_train)
  
  
  # Output: 
  # 1) features_list which is the list of selected features
  # 2) reduced_X_train_final which is the reduced X_train 
  
  
  # Get the MI scores between the features (continuous) in X_train and y_train (discrete)
  mmi_output = mmi(cts = X_train, disc = y_train)
  mmi_scores_output = mmi_output$mi
  MI_scores = as.vector(mmi_scores_output)
  
  
  # Get the indices of the features that they have MI_scores more than the MI_threshold
  True_index = which(MI_scores > MI_threshold)
  
  # Reduced the X_train by choosing the features in True_index
  reduced_X_train_one = X_train[, True_index]
  
  
  
  
  
  
  # Get the MI scores between the remained features (continuous) and the y_train (discrete)
  new_mmi_output = mmi(cts = reduced_X_train_one, disc = y_train)
  new_mmi_scores_output = new_mmi_output$mi
  final_MI_scores = as.vector(new_mmi_scores_output)
  # Sort the final_MI_scores
  inds = order(final_MI_scores, decreaseing = FALSE)
  # Order the reduced X_train based on ascending order of MI scores of features with y_train
  reduced_X_train_one = reduced_X_train_one[, inds]
  
  
  
  
  
  
  
  
  
  
  
  
  return(features_list, reduced_X_train_final)
  
}
```

