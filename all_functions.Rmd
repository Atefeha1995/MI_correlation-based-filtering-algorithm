





# Packages
```{r}
#library(tidyverse)
library(ggplot2)
library(caret)
library(randomForest)
library(mpmi)
```




# Read the X_train data
```{r}
X_train = read.csv(file = 'C:/Users/parvi/Dropbox/Stat 585-iastate/Project/MI_correlation-based-filtering-algorithm/X_train_data_stat585.csv', header = FALSE)


head(X_train)
dim(X_train)
```



# Read the y_train data
```{r}
y_train = read.csv(file = 'C:/Users/parvi/Dropbox/Stat 585-iastate/Project/MI_correlation-based-filtering-algorithm/y_train_data_stat585.csv', header = FALSE)


head(y_train)
dim(y_train)
```





# Read the X_test data
```{r}
X_test = read.csv(file = 'C:/Users/parvi/Dropbox/Stat 585-iastate/Project/MI_correlation-based-filtering-algorithm/X_test_data_stat585.csv', header = FALSE)


head(X_test)
dim(X_test)
```



# Read the y_test data
```{r}
y_test = read.csv(file = 'C:/Users/parvi/Dropbox/Stat 585-iastate/Project/MI_correlation-based-filtering-algorithm/y_test_data_stat585.csv', header = FALSE)


head(y_test)
dim(y_test)
```






# Main MI and correlation function
```{r}
correlation_based_filtering = function(X_tarin, y_train, MI_threshold, cor_threshold){
  
  # Inputs: 
  # 1) X_train
  # 2) y_train
  # 3) MI_threshold which is a threshold for the mutual information score between the features (X_train) and the response variable (y_train)
  # 4) cor_threshold which is a threshold for the linear correlation between the features (X_train)
  
  
  # Output: 
  # 1) features_list which is the list of selected features
  # 2) reduced_X_train_final which is the reduced X_train 
  
  
  # Get the MI scores between the features (continuous) in X_train and y_train (discrete)
  mmi_output = mmi(cts = X_train, disc = y_train)
  mmi_scores_output = mmi_output$mi
  MI_scores = as.vector(mmi_scores_output)
  
  
  # Get the indices of the features that they have MI_scores more than the MI_threshold
  True_index = which(MI_scores > MI_threshold)
  
  # Reduced the X_train by choosing the features in True_index
  reduced_X_train_one = X_train[, True_index]
  
  
  
  
  
  
  # Get the MI scores between the remained features (continuous) and the y_train (discrete)
  new_mmi_output = mmi(cts = reduced_X_train_one, disc = y_train)
  new_mmi_scores_output = new_mmi_output$mi
  final_MI_scores = as.vector(new_mmi_scores_output)
  # Sort the final_MI_scores
  inds = order(final_MI_scores, decreasing = FALSE)
  # Order the reduced X_train based on ascending order of MI scores of features with y_train
  reduced_X_train_one = reduced_X_train_one[, inds]
  
  
  
  
  
  
  # Get the names of columns in reduced_X_train_one and make a list by them
  features_list = t(t(colnames(reduced_X_train_one)))
  features_list = as.vector(features_list)
  # Get the number of the features (columns names) in the list
  num_features = length(features_list)
  
  
  
  
  
  for ( e in 1:num_features){# e is the index of the features in feature list starting from first feature
    q = e + 1   # q is the index of the features which is next (after) to the feature with index e
    while (q <= num_features){# while loop to check correlation between the pairs
      if (abs(cor(reduced_X_train_one[, e], reduced_X_train_one[, q])) > cor_threshold){
        q = q + 1 # update q
        num_features = num_features - 1 # decrease the num_features if the threshold is passed
        for (i in (q-2):num_features){
          features_list[i] = features_list[(i+1)] # Update the feature list
        }
        features_list = features_list[-(num_features + 1) ] # drop the last elemnt in the faeture list
        
      }else{
        q = q + 1 # Update q
        
      }
      
    }
    e = e + 1 # Update e
  }
  
  
  
  # Select the columns in the final feature list from the data set
  reduced_X_train_final = reduced_X_train_one[, features_list] 
  
  
  return(reduced_X_train_final)
  
}
```



# Test the function
```{r}
correlation_based_filtering(X_train, y_train, MI_threshold = 0.01, cor_threshold = 0.95)
```











